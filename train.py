import jsonimport osimport torchimport torch.utils.data as datafrom torch.utils.data import DataLoaderfrom torchvision.transforms import transformsfrom torch.utils.tensorboard import SummaryWriterfrom PIL import Imagefrom timm.models.vision_transformer_hybrid import vit_base_r50_s16_224from model_cct import cct_6_7x3_64_sinefrom model_cct import cct_4_3x6_64_sineos.environ["CUDA_VISIBLE_DEVICES"] = "0"device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")# device = 'cpu'imagebuffer = {}class Dataset(data.Dataset):    def __init__(self,path,transform = None):        self.path = path        self.transform = transform        self.image = []        # get label        self.class_names = sorted(os.listdir(path))        self.names2index = {v: k for k, v in enumerate(self.class_names)}        # read-in sequence and label        for label in self.class_names:            labelPath = os.path.join(path,label)            jsonpath = os.path.join(labelPath,"sequence.json")            with open(jsonpath, 'r', encoding='utf-8') as f:                sequence = json.load(f)            for i in range(0, len(sequence)):                self.image.append((sequence[i], self.names2index[label]))    def __len__(self):        return len(self.image)    def __getitem__(self, item):        path,label = self.image[item]        img = []        for i in range(0, len(path)):            if path[i] not in imagebuffer:                imagebuffer[path[i]] = Image.open(path[i])            tmp = Image.open(path[i])            img.append(self.transform(tmp))        return torch.cat(tuple(img)), label# for EOC-C or EOC-V testclass TestDataset(data.Dataset):    def __init__(self,path,transform = None):        self.path = path        self.transform = transform        self.image = []        # get type        self.type_names = sorted(os.listdir(path))        self.names2index = {v: k for k, v in enumerate(self.type_names)}        # read-in sequence and label        for type in self.type_names:            typePath = os.path.join(path,type)            jsonpath = os.path.join(typePath,"sequence.json")            with open(jsonpath, 'r', encoding='utf-8') as f:                sequence = json.load(f)            # for EOC-C            if type == 'SN_9566' or type == 'SN_C21':                for i in range(0, len(sequence)):                    self.image.append((sequence[i], 0))            else:                for i in range(0, len(sequence)):                    self.image.append((sequence[i], 3))            #for EOC-V            # for i in range(0, len(sequence)):            #     self.image.append((sequence[i], 3))    def __len__(self):        return len(self.image)    def __getitem__(self, item):        path,label = self.image[item]        img = []        for i in range(0, len(path)):            if path[i] not in imagebuffer:                imagebuffer[path[i]] = Image.open(path[i])            tmp = Image.open(path[i])            img.append(self.transform(tmp))        return torch.cat(tuple(img)), labeldef train_model(model,train_loader, valid_loader, criterion, optimizer, writer, num_epochs=20, scheduler = None, model_name = ""):    def train(model, train_loader,optimizer,criterion):        model.train(True)        total_loss = 0.0        total_correct = 0        for inputs, labels in train_loader:            inputs = inputs.to(device)            labels = labels.to(device)            optimizer.zero_grad()            outputs = model(inputs)            loss = criterion(outputs, labels)            _, predictions = torch.max(outputs, 1)            loss.backward()            optimizer.step()            total_loss += loss.item() * inputs.size(0)            total_correct += torch.sum(predictions == labels.data)        epoch_loss = total_loss / len(train_loader.dataset)        epoch_acc = total_correct.double() / len(train_loader.dataset)        return epoch_loss, epoch_acc.item()    def valid(model, valid_loader,criterion):        model.train(False)        total_loss = 0.0        total_correct = 0        for inputs, labels in valid_loader:            inputs = inputs.to(device)            labels = labels.to(device)            outputs = model(inputs)            loss = criterion(outputs, labels)            _, predictions = torch.max(outputs, 1)            total_loss += loss.item() * inputs.size(0)            total_correct += torch.sum(predictions == labels.data)        epoch_loss = total_loss / len(valid_loader.dataset)        epoch_acc = total_correct.double() / len(valid_loader.dataset)        return epoch_loss, epoch_acc.item()    best_acc = 0.0    base_epoch = 0    for epoch in range(base_epoch, base_epoch+num_epochs):        print('epoch:{:d}/{:d}'.format(epoch, base_epoch + num_epochs))        print('*' * 100)        train_loss, train_acc = train(model, train_loader,optimizer,criterion)        print("training: {:.4f}, {:.4f}".format(train_loss, train_acc))        valid_loss, valid_acc = valid(model, valid_loader,criterion)        print("validation: {:.4f}, {:.4f}".format(valid_loss, valid_acc))        if writer != None:            writer.add_scalar('Loss/test', valid_loss, epoch)            writer.add_scalar('Loss/train', train_loss, epoch)            writer.add_scalar('Accuracy/test', valid_acc, epoch)            writer.add_scalar('Accuracy/train', train_acc, epoch)        if scheduler:            scheduler.step()        if valid_acc > best_acc:            best_acc = valid_acc            best_model = model            torch.save(best_model, 'best_model/EOC-C/{}.pt'.format(model_name))if __name__ == '__main__':    trainTransforms = transforms.Compose([        # transforms.Resize([224, 224]),        transforms.RandomResizedCrop(64, scale=(0.95, 1.0), ratio=(0.9, 1.1)),        transforms.RandomHorizontalFlip(),        transforms.ToTensor(),    ])    validTransforms = transforms.Compose([        # transforms.Resize([224, 224]),        # transforms.RandomResizedCrop(64, scale=(0.95, 1.0), ratio=(0.9, 1.1)),        # transforms.RandomHorizontalFlip(),        transforms.ToTensor()    ])    train_data = Dataset('./data/EOC-C/train', transform=trainTransforms)    valid_data = TestDataset('./data/EOC-C/test', transform=validTransforms)    BATCH_SIZE = 32    train_loader = DataLoader(train_data, batch_size=BATCH_SIZE, shuffle=True)    valid_loader = DataLoader(valid_data, batch_size=BATCH_SIZE, shuffle=True)    # model = vit_base_r50_s16_224(pretrained=False)    model = cct_6_7x3_64_sine(num_classes = 4, n_input_channels = 1)    model = model.to(device)    criterion = torch.nn.CrossEntropyLoss()    epoch = 50    lr = 0.001    optimizer = torch.optim.SGD(model.parameters(), lr=lr, momentum=0.9)    scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=5, gamma=0.2, last_epoch=-1)    # milestones=[10,30]    # scheduler = torch.optim.lr_scheduler.MultiStepLR(optimizer, milestones, gamma=0.1, last_epoch=-1)    writer = SummaryWriter('runs/EOC-C/cct_6_7x3_64_sine_3')    train_model(model, train_loader, valid_loader, criterion, optimizer, writer, num_epochs=epoch, scheduler=scheduler, model_name='cct_6_7x3_64_sine_3')    writer.close()